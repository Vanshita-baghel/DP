PROBLEM STATEMENT:
Given an array arr[] which represents the dimensions of a sequence of matrices where the ith matrix has the dimensions (arr[i-1] x arr[i]) for i>=1, find the most efficient way to multiply these matrices together. The efficient way is the one that involves the least number of multiplications.

SOLUTION:

                                                                        APPROACH 1: RECURSION
                                                                        TIME COMPLEXITY:  exponential
class Solution {
    static int matrixMultiplication(int arr[]) {
        // code here
        
        int n= arr.length;
        
        return f(1,n-1,arr);
        
    }
    
    static int f(int i, int j, int[] arr){
        if(i==j)    return 0;
        
        
        int mini= Integer.MAX_VALUE;
        for(int k=i; k<j; k++){
            
            int steps= (arr[i-1]*arr[k]*arr[j])+ f(i,k, arr )+ f(k+1,j, arr);
            
            mini= Math.min(mini, steps);
        }
        
        return mini;
    }
}

                                                                        APPROACH 2: MEMOIZATION
                                                                        TIME COMPLEXITY: O(n*n)
                                                                        SPACE COMPLEXITY: O(n*n)+ O(n)
class Solution {
    //memoization
    static int matrixMultiplication(int arr[]) {
        // code here
        
        int n= arr.length;
        
        int[][] dp= new int[n][n];
        for(int i=0; i<n; i++){
            Arrays.fill(dp[i], -1);
        }
        
        return f(1,n-1,arr, dp);
        
    }
    
    static int f(int i, int j, int[] arr, int[][] dp){
        if(i==j)    return 0;
        
        if(dp[i][j] != -1)  return dp[i][j];
        
        int mini= Integer.MAX_VALUE;
        for(int k=i; k<j; k++){
            
            int steps= (arr[i-1]*arr[k]*arr[j])+ f(i,k, arr, dp)+ f(k+1,j, arr, dp);
            
            mini= Math.min(mini, steps);
        }
        
        return dp[i][j]= mini;
    }
}

                                                                        APPROACH 3: TABULATION
                                                                        TIME COMPLEXITY: O(n*n)
                                                                        SPACE COMPLEXITY: O(n*n)
class Solution {
    //tabulation
    static int matrixMultiplication(int arr[]) {
        // code here
        
        int n= arr.length;
        
        int[][] dp= new int[n][n];
        
        for(int i=n-1; i>0;i--){
            for(int j=i+1; j<n;j++){
                int mini= Integer.MAX_VALUE;
                for(int k=i; k<j; k++){
            
                    int steps= (arr[i-1]*arr[k]*arr[j])+ dp[i][k] + dp[k+1][j] ;
            
                    mini= Math.min(mini, steps);
                }
        
                dp[i][j]= mini;
            }
        }
        
        
        return dp[1][n-1];
        
    }
    
    
}
