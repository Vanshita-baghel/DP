PROBLEM STATEMENT:
Given an integer array nums, return true if you can partition the array into two subsets such that the sum of the elements in both subsets is equal or false otherwise.

SOLUTION:

                                                                                      APPROACH 1:  RECURSION
                                                                                    TIME COMPLEXITY: O(2^n)
                                                                                    SPACE COMPLEXITY: O(n) for stack space
class Solution {
    //recursion approach
    //time complexity: O(2^n)
    //space complexity: O(n) for stack space
    public boolean canPartition(int[] nums) {
        int totalSum=0;
        for(int i=0; i<nums.length; i++){
            totalSum+= nums[i];
        }
        if(totalSum%2 !=0)  return false;
        int target= totalSum/2;
        return f(nums, nums.length-1, target);
    }
    public boolean f(int[] nums, int ind, int target){
        if(target==0)   return true;
        if(ind==0)  return nums[ind]==target;
        boolean notTake= f(nums, ind-1, target);
        boolean take=false;
        if(nums[ind]<=target){
            take= f(nums, ind-1, target-nums[ind]);
        }
        return notTake||take;
    }
}

                                                                                      APPROACH 2:  MEMOIZATION
                                                                                    TIME COMPLEXITY: O(n*target)
                                                                                    SPACE COMPLEXITY: O(n) for stack space + O(n*target)  for dp array
class Solution {
    //memoization approach
    //time complexity: O(n*target)
    //space complexity: O(n) for stack space + O(n*target)  for dp array
    public boolean canPartition(int[] nums) {
        int totalSum=0;
        for(int i=0; i<nums.length; i++){
            totalSum+= nums[i];
        }
        if(totalSum%2 !=0)  return false;
        int target= totalSum/2;
        Boolean[][] dp= new Boolean[nums.length][target+1];
        return f(nums, nums.length-1, target, dp);
    }
    public boolean f(int[] nums, int ind, int target, Boolean[][] dp){
        if(target==0)   return true;
        if(ind==0)  return nums[ind]==target;
        if(dp[ind][target]!=null)   return dp[ind][target];

        boolean notTake= f(nums, ind-1, target, dp);
        boolean take=false;
        if(nums[ind]<=target){
            take= f(nums, ind-1, target-nums[ind], dp);
        }
        return dp[ind][target]= notTake||take;
    }
}

                                                                                      APPROACH 3:  TABULATION
                                                                                    TIME COMPLEXITY: O(n*target)
                                                                                    SPACE COMPLEXITY: O(n*target)  for dp array
    //tabulation approach
    //time complexity: O(n*target)
    //space complexity: O(n*target)  for dp array
    public boolean canPartition(int[] nums) {
        int totalSum=0;
        for(int i=0; i<nums.length; i++){
            totalSum+= nums[i];
        }
        if(totalSum%2 !=0)  return false;
        int target= totalSum/2;
        boolean[][] dp= new boolean[nums.length][target+1];

        for(int i=0; i<nums.length; i++){
            dp[i][0]= true;
        }

        if(nums[0]<=target)    dp[0][nums[0]]= true;

        for(int i=1; i<dp.length; i++){
            for(int j=1; j<dp[0].length; j++){
                boolean notTake= dp[i-1][j];
                boolean take= false;
                if(nums[i]<=j){
                    take= dp[i-1][j-nums[i]];
                }
                dp[i][j]= take || notTake;
            }
        }

        return dp[nums.length-1][target];
    }
}

                                                                                      APPROACH 4:  SPACE OPTIMISATION
                                                                                    TIME COMPLEXITY: O(n*target)
                                                                                    SPACE COMPLEXITY: O(n) 
class Solution {
    //space optimised approach
    //time complexity: O(n*target)
    //space complexity: O(n) 
    public boolean canPartition(int[] nums) {
        int totalSum=0;
        for(int i=0; i<nums.length; i++){
            totalSum+= nums[i];
        }
        if(totalSum%2 !=0)  return false;
        int target= totalSum/2;

        boolean[] prev= new boolean[target+1];
        boolean[] cur= new boolean[target+1];

        prev[0]= true;
        cur[0]= true;

        if(nums[0]<=target)    prev[nums[0]]= true;

        for(int i=1; i<nums.length; i++){
            for(int j=1; j<=target; j++){
                boolean notTake= prev[j];
                boolean take= false;
                if(nums[i]<=j){
                    take= prev[j-nums[i]];
                }
                cur[j]= take || notTake;
            }
            prev= cur.clone();
        }

        return prev[target];
    }
}
