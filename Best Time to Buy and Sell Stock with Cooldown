PROBLEM STATEMENT:
You are given an array prices where prices[i] is the price of a given stock on the ith day.

Find the maximum profit you can achieve. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times) with the following restrictions:

After you sell your stock, you cannot buy stock on the next day (i.e., cooldown one day).
Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).


SOLUTION:
                                                                                            APPROACH 1: RECURSION
                                                                                            TIME COMPLEXITY: O(2^n)
                                                                                            SPACE COMPLEXITY:= O(n)
class Solution {
    //recursion
    //tc= O(2^n)
    //sc= O(n)
    public int maxProfit(int[] prices) {
        
        int n= prices.length;

        return f(0,1, prices);
    }
    public int f(int ind, int buy, int[] prices){
        if(ind>prices.length-1) return 0;

        int profit=0;

        if(buy==1){
            profit= Math.max(-prices[ind]+f(ind+1,0,prices), f(ind+1,1, prices));
        }
        else{
            profit= Math.max(prices[ind]+ f(ind+2, 1, prices), f(ind+1, 0, prices));
        }

        return profit;
    }
}

                                                                                            APPROACH 2: MEMOIZATION
                                                                                            TIME COMPLEXITY: O(n*2)
                                                                                            SPACE COMPLEXITY: O(n*2) + O(n)
class Solution {
    //memoization
    //tc= O(n*2)
    //sc= O(n*2) + O(n)
    public int maxProfit(int[] prices) {
        
        int n= prices.length;

        int[][] dp= new int[n][2];

        for(int i=0; i<n; i++){
            Arrays.fill(dp[i], -1);
        }

        return f(0,1, prices, dp);
    }
    public int f(int ind, int buy, int[] prices, int[][] dp){
        if(ind>prices.length-1) return 0;

        int profit=0;

        if(dp[ind][buy] != -1)  return dp[ind][buy];

        if(buy==1){
            profit= Math.max(-prices[ind]+f(ind+1,0,prices, dp), f(ind+1,1, prices, dp));
        }
        else{
            profit= Math.max(prices[ind]+ f(ind+2, 1, prices,dp), f(ind+1, 0, prices, dp));
        }

        return dp[ind][buy]= profit;
    }
}
                                                                                            APPROACH 3:  TABULATION
                                                                                            TIME COMPLEXITY: O(n*2)
                                                                                            SPACE COMPLEXITY: O(n*2)
class Solution {
    //tabulation
    //tc= O(n*2)
    //sc= O(n*2) 
    public int maxProfit(int[] prices) {
        
        int n= prices.length;

        int[][] dp= new int[n+2][2];

        for(int ind=n-1; ind>=0; ind--){
            int profit=0;
            for(int buy=0; buy<2; buy++){
                if(buy==1){
                    profit= Math.max( -prices[ind]+dp[ind+1][0], dp[ind+1][1] );
                }
                else{
                    profit= Math.max( prices[ind]+dp[ind+2][1] , dp[ind+1][0] );
                }

                dp[ind][buy]= profit;
            }
        }

        return dp[0][1];
    }
    
}
                                                                                            APPROACH 4: SPACE OPTIMISATION
                                                                                            TIME COMPLEXITY: O(n*2)
                                                                                            SPACE COMPLEXITY: O(1)
class Solution {
    //space optimisation
    //tc= O(n*2)
    //sc= O(2) 
    public int maxProfit(int[] prices) {
        
        int n= prices.length;

        int[] postNext= new int[2];
        int[] next= new int[2];
        

        for(int ind=n-1; ind>=0; ind--){
            int profit=0;
            int[] cur= new int[2];
            for(int buy=0; buy<2; buy++){
                if(buy==1){
                    profit= Math.max( -prices[ind]+next[0], next[1] );
                }
                else{
                    profit= Math.max( prices[ind]+postNext[1] , next[0] );
                }

                cur[buy]= profit;
            }
            postNext= next;
            next= cur;
        }

        return next[1];
    }
    
}
