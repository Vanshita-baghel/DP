PROBLEM STATEMENT:
Given a rod of length ‘N’ units. The rod can be cut into different sizes and each size has a cost associated with it. Determine the maximum cost obtained by cutting the rod and selling its pieces.

Note:
1. The sizes will range from 1 to ‘N’ and will be integers.

2. The sum of the pieces cut should be equal to ‘N’.

3. Consider 1-based indexing.

SOLUTION:
                                                                                            APPROACH 1: RECURSION
                                                                                            TIME COMPLEXITY> O(2^n)
                                                                                            SPACE COMPLEXITY: O(n)
import java.util.Arrays;
public class Solution {
	//recursion
	public static int cutRod(int price[], int n) {

		return f(n-1, n, price);
	}
	public static int f(int ind, int currRodLength, int[] price){
		if(ind==0){
			return currRodLength * price[0];
		}

		int notTake= f(ind-1, currRodLength, price);
		int take=Integer.MIN_VALUE;
		int rodLength= ind+1;
		if(rodLength<= currRodLength)	take= price[ind]+ f(ind, currRodLength-rodLength, price);

		return Math.max(take, notTake);
	}
}
                                                                                            APPROACH 2: MEMOIZATION
                                                                                            TIME COMPLEXITY: O( n*n)
                                                                                            SPACE COMPLEXITY: O(n) +  O( n*n)
import java.util.Arrays;
public class Solution {
	//memoization
	public static int cutRod(int price[], int n) {
		int[][] dp= new int[n][n+1];

		for(int i=0; i<n; i++){
			Arrays.fill(dp[i], -1);
		}

		return f(n-1, n, price, dp);
	}
	public static int f(int ind, int currRodLength, int[] price, int[][] dp){
		if(ind==0){
			return currRodLength * price[0];
		}

		if(dp[ind][currRodLength] != -1)	return dp[ind][currRodLength];
		int notTake= f(ind-1, currRodLength, price, dp);
		int take=Integer.MIN_VALUE;
		int rodLength= ind+1;
		if(rodLength<= currRodLength)	take= price[ind]+ f(ind, currRodLength-rodLength, price, dp);

		return dp[ind][currRodLength] = Math.max(take, notTake);
	}
}
                                                                                            APPROACH 3: TABULATION
                                                                                            TIME COMPLEXITY: O( n*n)
                                                                                            SPACE COMPLEXITY:  O( n*n)
import java.util.Arrays;
public class Solution {
	//tabulation
	public static int cutRod(int price[], int n) {
		int[][] dp= new int[n][n+1];

		for(int i=0; i<=n; i++){
			dp[0][i]= i*price[0];
		}

		for(int i=1; i<n; i++){
			for(int j=0; j<=n; j++){
				int notTake= dp[i-1][j]; 
				int take=Integer.MIN_VALUE;
				int rodLength= i+1;
				if(rodLength<= j)	take= price[i]+ dp[i][j-rodLength]; 
				dp[i][j] = Math.max(take, notTake);
			}
		}

		return dp[n-1][n];
	}
	
}
                                                                                            APPROACH 4: SPACE OPTIMISATION
                                                                                            TIME COMPLEXITY:  O( n*n)
                                                                                            SPACE COMPLEXITY: O(2*n)
import java.util.*;
public class Solution {
	//space optimisation
	public static int cutRod(int price[], int n) {
		int[] prev= new int[n+1];
		int[] cur= new int[n+1];

		for(int i=0; i<=n; i++){
			prev[i]= i*price[0];
		}

		for(int i=1; i<n; i++){
			for(int j=0; j<=n; j++){
				int notTake= prev[j]; 
				int take=Integer.MIN_VALUE;
				int rodLength= i+1;
				if(rodLength<= j)	take= price[i]+ cur[j-rodLength]; 
				cur[j] = Math.max(take, notTake);
			}
			prev= cur.clone();
		}

		return prev[n];
	}
	
}
                                                                                            APPROACH 5: SPACE OPTIMISATION 2
                                                                                            TIME COMPLEXITY:   O( n*n)
                                                                                            SPACE COMPLEXITY: O(n)
import java.util.*;
public class Solution {
	//space optimisation 2
	public static int cutRod(int price[], int n) {
		int[] prev= new int[n+1];

		for(int i=0; i<=n; i++){
			prev[i]= i*price[0];
		}

		for(int i=1; i<n; i++){
			for(int j=0; j<=n; j++){
				int notTake= prev[j]; 
				int take=Integer.MIN_VALUE;
				int rodLength= i+1;
				if(rodLength<= j)	take= price[i]+ prev[j-rodLength]; 
				prev[j] = Math.max(take, notTake);
			}	
		}

		return prev[n];
	}
	
}
