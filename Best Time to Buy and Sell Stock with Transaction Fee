PROBLEM STATEMENT:
You are given an array prices where prices[i] is the price of a given stock on the ith day, and an integer fee representing a transaction fee.

Find the maximum profit you can achieve. You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction.

SOLUTION:

                                                                                        approach 1: RECURSION
                                                                                        TIME COMPLEXITY: O(2^n)
                                                                                        SPACE COMPLEXITY: O(n)
class Solution {
    //recursion
    //tc= O(2^n)
    //sc= O(n)
    public int maxProfit(int[] prices, int fee) {
        
        int n= prices.length;

        return f(0,1,prices, fee);
    }

    public int f(int ind, int buy, int[] prices, int fee){
        if(ind > prices.length-1)   return 0;

        int profit=0;

        if(buy==1){
            profit= Math.max(-prices[ind]+f(ind+1, 0, prices, fee), f(ind+1, 1, prices, fee));
        }
        else{
            profit= Math.max(prices[ind]-fee+f(ind+1,1,prices,fee), f(ind+1,0,prices,fee));
        }
        return profit;
    }
}
                                                                                        approach 2: MEMOIZATION
                                                                                        TIME COMPLEXITY: O(n*2)
                                                                                        SPACE COMPLEXITY: O(n*2)+ O(n)
class Solution {
    //memoization
    //tc= O(n*2)
    //sc= O(n) + O(n*2)
    public int maxProfit(int[] prices, int fee) {
        
        int n= prices.length;

        int[][] dp= new int[n][2];

        for(int i=0; i<n; i++){
            Arrays.fill(dp[i], -1);
        }

        return f(0,1,prices, fee, dp);
    }

    public int f(int ind, int buy, int[] prices, int fee, int[][] dp){
        if(ind > prices.length-1)   return 0;

        int profit=0;

        if(dp[ind][buy] != -1)  return dp[ind][buy];

        if(buy==1){
            profit= Math.max(-prices[ind]+f(ind+1, 0, prices, fee, dp), f(ind+1, 1, prices, fee, dp));
        }
        else{
            profit= Math.max(prices[ind]-fee+f(ind+1,1,prices,fee, dp), f(ind+1,0,prices,fee, dp));
        }
        return dp[ind][buy]= profit;
    }
}
                                                                                        approach 3: TABULATION
                                                                                        TIME COMPLEXITY: O(n*2)
                                                                                        SPACE COMPLEXITY: O(n*2)
class Solution {
    //tabulation
    //tc= O(n*2)
    //sc= O(n*2)
    public int maxProfit(int[] prices, int fee) {
        
        int n= prices.length;

        int[][] dp= new int[n+1][2];

        for(int ind=n-1; ind>=0; ind--){
            int profit=0;
            for(int buy=0; buy<2; buy++){
                if(buy==1){
                    profit= Math.max(-prices[ind]+dp[ind+1][0] , dp[ind+1][1] );
        }
                else{
                    profit= Math.max(prices[ind]-fee+dp[ind+1][1], dp[ind+1][0] );
                }
                dp[ind][buy]= profit;
            }
        }

        return dp[0][1];
    }

}
                                                                                        approach 4: SPACE OPTIMISATON
                                                                                        TIME COMPLEXITY: O(n*2)
                                                                                        SPACE COMPLEXITY: O(1)
class Solution {
    //space optimisation
    //tc= O(n*2)
    //sc= O(1)
    public int maxProfit(int[] prices, int fee) {
        
        int n= prices.length;

        int[] after= new int[2];
        int[] cur= new int[2];

        for(int ind=n-1; ind>=0; ind--){
            int profit=0;
            for(int buy=0; buy<2; buy++){
                if(buy==1){
                    profit= Math.max(-prices[ind]+after[0] , after[1] );
        }
                else{
                    profit= Math.max(prices[ind]-fee+after[1], after[0] );
                }
                cur[buy]= profit;
            }
            int[] temp= after;
            after= cur;
            cur= after;
        }

        return after[1];
    }

    public int f(int ind, int buy, int[] prices, int fee, int[][] dp){
        if(ind > prices.length-1)   return 0;

        int profit=0;

        if(dp[ind][buy] != -1)  return dp[ind][buy];

        if(buy==1){
            profit= Math.max(-prices[ind]+f(ind+1, 0, prices, fee, dp), f(ind+1, 1, prices, fee, dp));
        }
        else{
            profit= Math.max(prices[ind]-fee+f(ind+1,1,prices,fee, dp), f(ind+1,0,prices,fee, dp));
        }
        return dp[ind][buy]= profit;
    }
}
