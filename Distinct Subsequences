PROBLEM STATEMENT:
Given two strings s and t, return the number of distinct subsequences of s which equals t.

The test cases are generated so that the answer fits on a 32-bit signed integer.

SOLUTION:

                                                                                            APPROACH 1: RECURSION
                                                                                            TIME COMPLEXITY: exponential
                                                                                            SPACE COMPLEXITY: O(n+m)
class Solution {
    //recursion
    //tc= exponential 
    //sc = O(n+m)
    public int numDistinct(String s, String t) {
        int n= s.length();
        int m= t.length();

        return f(n-1, m-1, s, t);
    }
    public int f(int i, int j, String s, String t){

        if(j<0) return 1;
        if(i<0) return 0;

        if(s.charAt(i)== t.charAt(j)){
            return f(i-1, j-1, s ,t) + f(i-1, j,s,t);
        }
        return f(i-1, j,s, t);
    }
}

                                                                                            APPROACH 2: MEMOIZATION
                                                                                            TIME COMPLEXITY: O(n*m)
                                                                                            SPACE COMPLEXITY: O(n*m) + o(n+m)
class Solution {
    //memoization
    //tc= O(n*m) 
    //sc = O(n*m)
    public int numDistinct(String s, String t) {
        int n= s.length();
        int m= t.length();

        int[][] dp= new int[n][m];

        for(int i=0; i<n; i++){
            Arrays.fill(dp[i], -1);
        }

        return f(n-1, m-1, s, t, dp);
    }
    public int f(int i, int j, String s, String t, int[][] dp){

        if(j<0) return 1;
        if(i<0) return 0;

        if(dp[i][j] != -1)  return dp[i][j];

        if(s.charAt(i)== t.charAt(j)){
            return dp[i][j]= f(i-1, j-1, s ,t, dp) + f(i-1, j,s,t, dp);
        }
        return dp[i][j]= f(i-1, j,s, t, dp);
    }
}

                                                                                            APPROACH 3: TABULATION
                                                                                            TIME COMPLEXITY: O(n*m)
                                                                                            SPACE COMPLEXITY: O(n*m)
class Solution {
    //tabulation
    //tc= O(n*m) 
    //sc = O(n*m)
    public int numDistinct(String s, String t) {
        int n= s.length();
        int m= t.length();

        int[][] dp= new int[n+1][m+1];

        //base case
        for(int i=0; i<=n; i++){
            dp[i][0]= 1;
        }

        //loop
        for(int i=1; i<=n; i++){
            for(int j=1; j<=m; j++){
                //copy the reccurrence
                if(s.charAt(i-1)== t.charAt(j-1)){
                    dp[i][j]= dp[i-1][j-1] + dp[i-1][j] ;
                }
                else dp[i][j]= dp[i-1][j] ;
            }
        }

        return dp[n][m];
    }
    public int f(int i, int j, String s, String t, int[][] dp){

        if(j==0) return 1;
        if(i==0) return 0;

        if(dp[i][j] != -1)  return dp[i][j];

        if(s.charAt(i-1)== t.charAt(j-1)){
            return dp[i][j]= f(i-1, j-1, s ,t, dp) + f(i-1, j,s,t, dp);
        }
        return dp[i][j]= f(i-1, j,s, t, dp);
    }
}

                                                                                            APPROACH 4: SPACE OPTIMISATION
                                                                                            TIME COMPLEXITY: O(n*m)
                                                                                            SPACE COMPLEXITY: O(m)
class Solution {
    //space optimisation
    //tc= O(n*m) 
    //sc = O(m)
    public int numDistinct(String s, String t) {
        int n= s.length();
        int m= t.length();

        int[] prev= new int[m+1];
        int[] cur= new int[m+1];

        //base case
        cur[0]=1;
        prev[0]=1;

        //loop
        for(int i=1; i<=n; i++){
            for(int j=1; j<=m; j++){
                //copy the reccurrence
                if(s.charAt(i-1)== t.charAt(j-1)){
                    cur[j]= prev[j-1] + prev[j] ;
                }
                else cur[j]= prev[j] ;
            }
            prev= cur.clone();
        }

        return prev[m];
    }
    
}
                                                                                            APPROACH 5: SPACE OPTIMISATION 2
                                                                                            TIME COMPLEXITY: O(n*m)
                                                                                            SPACE COMPLEXITY: O(m)
class Solution {
    //space optimisation 2
    //tc= O(n*m) 
    //sc = O(m)
    public int numDistinct(String s, String t) {
        int n= s.length();
        int m= t.length();

        int[] prev= new int[m+1];

        //base case
        prev[0]=1;

        //loop
        for(int i=1; i<=n; i++){
            for(int j=m; j>0; j--){
                //copy the reccurrence
                if(s.charAt(i-1)== t.charAt(j-1)){
                    prev[j]= prev[j-1] + prev[j] ;
                }
            }
        }

        return prev[m];
    }
    
}
