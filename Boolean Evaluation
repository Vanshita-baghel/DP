Problem statement
You are given an expression 'exp' in the form of a string where operands will be : (TRUE or FALSE), and operators will be : (AND, OR or XOR).



Now you have to find the number of ways we can parenthesize the expression such that it will evaluate to TRUE.



As the answer can be very large, return the output modulo 1000000007.



Note :

‘T’ will represent the operand TRUE.
‘F’ will represent the operand FALSE.
‘|’ will represent the operator OR.
‘&’ will represent the operator AND.
‘^’ will represent the operator XOR.

SOLUTION:

                                                                                                    APPROACH 1: recursion
                                                                                                    TIME COMPLEXITY: O(2ⁿ)
                                                                                                    SPACE COMPLEXITY: O(n)
public class Solution {
    // recursion
    public static int evaluateExp(String exp) {

        int n= exp.length();

        return f(0,n-1,true, exp);
    }

    public static int f(int i, int j, boolean isTrue, String exp){

        if(i>j) return 0;
        if(i==j){
            if(isTrue){
                if(exp.charAt(i)=='T')  return 1;
                else    return 0;
            }
            else{
                if(exp.charAt(i)=='F')  return 1;
                else return 0;
            }
        }

        int ways=0;
        for(int ind=i+1; ind<j; ind+=2){
            int lT= f(i,ind-1,true,exp);
            int lF= f(i, ind-1,false,exp);
            int rT= f(ind+1, j, true, exp);
            int rF= f(ind+1,j, false, exp);

            char op= exp.charAt(ind);
            if(op=='&'){
                if(isTrue){
                    ways+= (lT*rT);
                }
                else{
                    ways+= (lF*rT) + (lT*rF)+  (lF*rF);
                }
            }
            else if(op== '|'){
                if(isTrue){
                    ways+= (lF*rT) + (lT*rF)+ (lT*rT);
                }
                else{
                    ways+= (lF*rF);
                }
            }
            else{
                if(isTrue){
                    ways+= (lF*rT) + (lT*rF);
                }
                else{
                    ways+= (lT*rT) +(lF*rF);
                }
            }
        }
        
        return ways;


    }
}

                                                                                                    APPROACH 2: MEMOIZATION
                                                                                                    TIME COMPLEXITY: O(n³)
                                                                                                    SPACE COMPLEXITY:o(n^2) + O(n)
import java.util.*;

public class Solution {
    // memoization
    static int MOD= 1_000_000_007;
    public static int evaluateExp(String exp) {

        int n= exp.length();

        int[][][] dp= new int[n][n][2];

        for(int i=0; i<n; i++){
            for(int j=0; j<n; j++){
                for(int k=0; k<2; k++){
                    dp[i][j][k]= -1;
                }
            }
            
        }

        return f(0,n-1,1, exp, dp);
    }

    public static int f(int i, int j, int isTrue, String exp, int[][][] dp){

        if(i>j) return 0;
        if(i==j){
            if(isTrue==1){
                if(exp.charAt(i)=='T')  return 1;
                else    return 0;
            }
            else{
                if(exp.charAt(i)=='F')  return 1;
                else return 0;
            }
        }

        if(dp[i][j][isTrue] != -1)  return dp[i][j][isTrue];

        long ways=0;
        for(int ind=i+1; ind<j; ind+=2){
            int lT= f(i,ind-1,1,exp, dp);
            int lF= f(i, ind-1,0,exp, dp);
            int rT= f(ind+1, j, 1, exp,dp);
            int rF= f(ind+1,j, 0, exp,dp);

            char op= exp.charAt(ind);
            if(op=='&'){
                if(isTrue==1){
                    ways= (ways+ (1L *lT*rT)%MOD)%MOD;
                }
                else{
                    ways=(ways+ (1L *lF*rT)%MOD + (1L *lT*rF)%MOD+  (1L *lF*rF)%MOD)%MOD;
                }
            }
            else if(op== '|'){
                if(isTrue==1){
                    ways=(ways+ (1L *lF*rT)%MOD + (1L *lT*rF)%MOD+ (1L *lT*rT)%MOD)%MOD;
                }
                else{
                    ways= (ways+ (1L *lF*rF)%MOD)%MOD;
                }
            }
            else{
                if(isTrue==1){
                    ways= (ways+ (1L *lF*rT)%MOD + (1L *lT*rF)%MOD)%MOD;
                }
                else{
                    ways= (ways+ (1L *lT*rT)%MOD +(1L *lF*rF)%MOD)%MOD;
                }
            }
        }
        
        return dp[i][j][isTrue]= (int)ways;


    }
}

                                                                                                    APPROACH 3: TABULATION
                                                                                                    TIME COMPLEXITY: O(n³)
                                                                                                    SPACE COMPLEXITY: O(n²)
import java.util.*;

public class Solution {
    // tabulation
    static int MOD= 1_000_000_007;
    public static int evaluateExp(String exp) {

        int n= exp.length();

        int[][][] dp= new int[n][n][2];

        for(int i=n-1; i>=0; i--)   {
            for(int j=0; j<n; j++){
                for(int k=0; k<2; k++){

                    if(i>j) continue;

                    //base case
                    if(i==j){
                        if(k==1){
                            if(exp.charAt(i)=='T')  dp[i][j][k]= 1;
                            else    dp[i][j][k]= 0;
                        }
                        else{
                            if(exp.charAt(i)=='F')  dp[i][j][k]= 1;
                            else dp[i][j][k]= 0;
                        }
                        continue;
                    } 


                    long ways=0;
                    for(int ind=i+1; ind<j; ind+=2){
                        int lT= dp[i][ind-1][1] ;
                        int lF= dp[i][ind-1][0];
                        int rT= dp[ind+1][j][1] ;
                        int rF= dp[ind+1][j][0]  ;

                        char op= exp.charAt(ind);
                        if(op=='&'){
                        if(k==1){
                            ways= (ways+ (1L *lT*rT)%MOD)%MOD;
                        }
                        else{
                            ways=(ways+ (1L *lF*rT)%MOD + (1L *lT*rF)%MOD+  (1L *lF*rF)%MOD)%MOD;
                        }
                        }
                        else if(op== '|'){
                            if(k==1){
                                ways=(ways+ (1L *lF*rT)%MOD + (1L *lT*rF)%MOD+ (1L *lT*rT)%MOD)%MOD;
                            }
                            else{
                                ways= (ways+ (1L *lF*rF)%MOD)%MOD;
                            }
                        }
                        else{
                            if(k==1){
                                ways= (ways+ (1L *lF*rT)%MOD + (1L *lT*rF)%MOD)%MOD;
                            }
                            else{
                                ways= (ways+ (1L *lT*rT)%MOD +(1L *lF*rF)%MOD)%MOD;
                            }
                        }
                    }
        
                    dp[i][j][k]= (int)ways;

                }
            }
        }

        return dp[0][n-1][1] ;
    }
}
