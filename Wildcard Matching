PROBLEM STATEMENT:
Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?' and '*' where:

'?' Matches any single character.
'*' Matches any sequence of characters (including the empty sequence).
The matching should cover the entire input string (not partial).

SOLUTION:

                                                                                          APPROACH 1: RECURSION
                                                                                          TIME COMPLEXITY: exponential
                                                                                          SPACE COMPLEXTIY: O(n+m)
class Solution {
    //recursion
    //tcc= exponential
    //sc= O(n+m)
    public boolean isMatch(String s, String p) {
        int n=s.length(), m= p.length();

        return f(m-1, n-1, p,s); 
    }
    public boolean f(int i, int j, String s1, String s2){
        if(i<0 && j>=0) return false;
        if(i<0 && j<0)  return true;
        if(i>=0 && j<0){
            for(int a=0; a<=i; a++){
                if(s1.charAt(a) != '*') return false;
            }
            return true;
        }

        if(s1.charAt(i)== s2.charAt(j) || s1.charAt(i)== '?'){
            return f(i-1, j-1, s1, s2);
        }
        else if(s1.charAt(i)== '*'){
            return f(i-1,j,s1,s2) || f(i,j-1,s1,s2);
        }
        return false;
    }
}

                                                                                          APPROACH 2: MEMOIZATION
                                                                                          TIME COMPLEXITY: O(n*m)
                                                                                          SPACE COMPLEXTIY: O(n*m) + O(n+m)
class Solution {
    //memoization
    //tcc= O(n*m)
    //sc= O(n+m) + O(n*m)
    public boolean isMatch(String s, String p) {
        int n=s.length(), m= p.length();

        Boolean[][] dp= new Boolean[m][n];


        return f(m-1, n-1, p,s,dp); 
    }
    public boolean f(int i, int j, String s1, String s2, Boolean[][] dp){
        if(i<0 && j>=0) return false;
        if(i<0 && j<0)  return true;
        if(i>=0 && j<0){
            for(int a=0; a<=i; a++){
                if(s1.charAt(a) != '*') return false;
            }
            return true;
        }

        if(dp[i][j] != null)    return dp[i][j];

        if(s1.charAt(i)== s2.charAt(j) || s1.charAt(i)== '?'){
            return dp[i][j]=f(i-1, j-1, s1, s2,dp);
        }
        else if(s1.charAt(i)== '*'){
            return dp[i][j]= f(i-1,j,s1,s2,dp) || f(i,j-1,s1,s2,dp);
        }
        return dp[i][j]= false;
    }
}

                                                                                          APPROACH 3: TABULATION
                                                                                          TIME COMPLEXITY: O(n*m)
                                                                                          SPACE COMPLEXTIY: O(n*m)
class Solution {
    //tabulation
    //tc= O(n*m)
    //sc= O(n*m)
    public boolean isMatch(String s, String p) {
        int n=s.length(), m= p.length();

        boolean[][] dp= new boolean[m+1][n+1];
        dp[0][0]= true;

        for(int j=1; j<=n; j++){
            dp[0][j]= false;
        }

        for(int i=1; i<=m; i++){
            boolean flag= true;
            for(int a=1; a<=i; a++){  
                if(p.charAt(a-1) != '*'){
                    flag= false;
                    break;
                } 
            }
            dp[i][0]= flag;
        }

        for(int i=1; i<=m; i++){
            for(int j=1; j<=n; j++){
                if(p.charAt(i-1)== s.charAt(j-1) || p.charAt(i-1)== '?'){
                    dp[i][j]=dp[i-1][j-1] ;
                }
                else if(p.charAt(i-1)== '*'){
                    dp[i][j]= dp[i-1][j]  || dp[i][j-1] ;
                }
                else     dp[i][j]= false;
            }
        }
        return dp[m][n]; 
    }

}

                                                                                          APPROACH 4: SPACE OPTIMISATION
                                                                                          TIME COMPLEXITY: O(n*m)
                                                                                          SPACE COMPLEXTIY: O(n)
class Solution {
    //space optimisation 2
    //tc= O(n*m)
    //sc= O(n)
    public boolean isMatch(String s, String p) {
        int n=s.length(), m= p.length();

        boolean[] prev= new boolean[n+1];
        boolean[] cur= new boolean[n+1];

        prev[0]= true;

        for(int j=1; j<=n; j++){
            prev[j]= false;
        }

        for(int i=1; i<=m; i++){
            
        }

        for(int i=1; i<=m; i++){
            boolean flag= true;
            for(int a=1; a<=i; a++){  
                if(p.charAt(a-1) != '*'){
                    flag= false;
                    break;
                } 
            }
            cur[0]= flag;

            for(int j=1; j<=n; j++){
                if(p.charAt(i-1)== s.charAt(j-1) || p.charAt(i-1)== '?'){
                    cur[j]=prev[j-1] ;
                }
                else if(p.charAt(i-1)== '*'){
                    cur[j]= prev[j]  || cur[j-1] ;
                }
                else     cur[j]= false;
            }
            prev= cur.clone();
        }
        return prev[n]; 
    }

}
